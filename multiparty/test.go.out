
package main

import (
	"net"
	"os"

	"github.com/JoeyEremondi/GoSesh/dynamic"
	"github.com/JoeyEremondi/GoSesh/multiparty"
)

func handleError(e error){
	panic(e)
}

var PROTOCOL string =  "udp"
var BUFFERSIZE int = 1000000

// calls this function to set it up
// ConnectNode : Set up a connection for a node
func ConnectNode(laddress string) *net.UDPConn {
	laddressUDP, addrError := net.ResolveUDPAddr(PROTOCOL, laddress)
	handleError(addrError)

	conn, connError := net.ListenUDP(PROTOCOL, laddressUDP)
	handleError(connError)
	conn.SetReadBuffer(BUFFERSIZE)

	return conn
}



//Higher order function: takes in a (possibly empty) map of addresses for channels
//Then returns the function which looks up the address for that channel (if it exists)
//And does the write
func makeChannelWriter(conn *net.UDPConn, addrMap *map[dynamic.Participant]*net.UDPAddr)(func(dynamic.Participant, []byte, *net.UDPAddr) (int, error)){
	return func(p dynamic.Participant, b []byte, addr *net.UDPAddr) (int, error){
		//TODO get addr from map!
		return conn.WriteToUDP(b, addr)
	}
}

func makeChannelReader(conn *net.UDPConn, addrMap *map[dynamic.Participant]*net.UDPAddr)(func(dynamic.Participant, []byte) (int, *net.UDPAddr, error)){
	return func(p dynamic.Participant, b []byte) (int, *net.UDPAddr, error){
		return conn.ReadFromUDP(b)
	}
}

func main(){
	argsWithoutProg := os.Args[1:]
	
if argsWithoutProg[1] == "--foo"{
	foo_main(argsWithoutProg[2:])
}
			
if argsWithoutProg[1] == "--bar"{
	bar_main(argsWithoutProg[2:])
}
			
}

func foo_main(args []string){
	conn := ConnectNode("foo")
	checker := dynamic.CreateChecker(multiparty.LocalRecursiveType{Bind:multiparty.LocalNameType("T"), Body:multiparty.LocalSendType{Participant:"bar", Value:"int", Next:multiparty.LocalBranchingType{Participant:"bar", Branches:map[string]multiparty.LocalType{"isGood":multiparty.LocalEndType{}, "isBad":multiparty.LocalNameType("T")}}}})
	addrMap := make(map[dynamic.Participant]*net.UDPAddr)
	addrMaker := func(p dynamic.Participant)*net.UDPAddr{
		addr, ok := addrMap[p]
		if ok && addr != nil {
			return addr
		} else {
			addr, _ := net.ResolveUDPAddr("udp", p.String())
			//TODO check err
			addrMap[p] = addr
			return addr
		}
	}
	readFun := makeChannelReader(conn, &addrMap)
	writeFun := makeChannelWriter(conn, &addrMap)
	
T:
for {
	
var sendArg int //TODO put a value here
sendBuf := checker.PrepareSend("TODO govec send message", sendArg)
checker.WriteToUDP("bar", writeFun, sendBuf, addrMaker)

var ourBuf []byte
checker.ReadFromUDP("bar", readFun, ourBuf)
var receivedLabel string
checker.UnpackReceive("TODO Unpack Message", ourBuf, &receivedLabel)
switch receivedLabel{
	
	case "isGood":
		return

			
	case "isBad":
		continue T

			
default:
	panic("Invalid label sent at selection choice")
}
		
	
}
		
}
			
func bar_main(args []string){
	conn := ConnectNode("bar")
	checker := dynamic.CreateChecker(multiparty.LocalRecursiveType{Bind:multiparty.LocalNameType("T"), Body:multiparty.LocalReceiveType{Participant:"foo", Value:"int", Next:multiparty.LocalSelectionType{Participant:"foo", Branches:map[string]multiparty.LocalType{"isGood":multiparty.LocalEndType{}, "isBad":multiparty.LocalNameType("T")}}}})
	addrMap := make(map[dynamic.Participant]*net.UDPAddr)
	addrMaker := func(p dynamic.Participant)*net.UDPAddr{
		addr, ok := addrMap[p]
		if ok && addr != nil {
			return addr
		} else {
			addr, _ := net.ResolveUDPAddr("udp", p.String())
			//TODO check err
			addrMap[p] = addr
			return addr
		}
	}
	readFun := makeChannelReader(conn, &addrMap)
	writeFun := makeChannelWriter(conn, &addrMap)
	
T:
for {
	
var recvBuf []byte
checker.ReadFromUDP("foo", readFun, recvBuf)
var receivedValue int
checker.UnpackReceive("TODO unpack message", recvBuf, &receivedValue)

var labelToSend = "isGood" //TODO which label to send
buf := checker.PrepareSend("TODO Select message", labelToSend)
checker.WriteToUDP("foo", writeFun, buf, addrMaker)
switch labelToSend{
	
	case "isGood":
		return

			
	case "isBad":
		continue T

			
default:
	panic("Invalid label sent at selection choice")
}
		
	
}
		
}
			
	