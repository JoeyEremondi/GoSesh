
package main

import (
	"net"
	"os"

	"github.com/JoeyEremondi/GoSesh/dynamic"

)


//Higher order function: takes in a (possibly empty) map of addresses for channels
//Then returns the function which looks up the address for that channel (if it exists)
//And does the write
func makeChannelWriter(addrMap *map[dynamic.Participant]net.Addr)(func(dynamic.Participant, []byte, net.Addr) (int, error)){
	return func(p dynamic.Participant, b []byte, addr net.Addr) (int, error){
		panic("TODO")

	}
}

func makeChannelReader(addrMap *map[dynamic.Participant]net.Addr)(func(dynamic.Participant, []byte) (int, net.Addr, error)){
	return func(p dynamic.Participant, b []byte) (int, net.Addr, error){
		panic("TODO!")
	}
}

func main(){
	argsWithoutProg := os.Args[1:]
	
if argsWithoutProg[1] == "--foo"{
	foo_main(argsWithoutProg[2:])
}
			
if argsWithoutProg[1] == "--bar"{
	bar_main(argsWithoutProg[2:])
}
			
}

func foo_main(args []string){
	var checker dynamic.Checker
	addrMap := make(map[dynamic.Participant]net.Addr)
	addrMaker := func(p dynamic.Participant)net.Addr{
		addr, ok := addrMap[p]
		if ok && addr != nil {
			return addr
		} else {
			addr, _ := net.ResolveUDPAddr("udp", p.String())
			//TODO check err
			addrMap[p] = addr
			return addr
		}
	}
	readFun := makeChannelReader(&addrMap)
	writeFun := makeChannelWriter(&addrMap)
	
T:
for {
	
var sendArg int //TODO put a value here
sendBuf := checker.PrepareSend("TODO govec send message", sendArg)
checker.WriteTo("bar", writeFun, sendBuf, addrMaker)

var ourBuf []byte
checker.ReadFrom("bar", readFun, ourBuf)
var receivedLabel string
checker.UnpackReceive("TODO Unpack Message", ourBuf, &receivedLabel)
switch receivedLabel{
	
	case "isGood":
		return

			
	case "isBad":
		continue T

			
default:
	panic("Invalid label sent at selection choice")
}
		
	
}
		
}
			
func bar_main(args []string){
	var checker dynamic.Checker
	addrMap := make(map[dynamic.Participant]net.Addr)
	addrMaker := func(p dynamic.Participant)net.Addr{
		addr, ok := addrMap[p]
		if ok && addr != nil {
			return addr
		} else {
			addr, _ := net.ResolveUDPAddr("udp", p.String())
			//TODO check err
			addrMap[p] = addr
			return addr
		}
	}
	readFun := makeChannelReader(&addrMap)
	writeFun := makeChannelWriter(&addrMap)
	
T:
for {
	
var recvBuf []byte
checker.ReadFrom("foo", readFun, recvBuf)
var receivedValue int
checker.UnpackReceive("TODO unpack message", recvBuf, &receivedValue)

var labelToSend = "isGood" //TODO which label to send
buf := checker.PrepareSend("TODO Select message", labelToSend)
checker.WriteTo("foo", writeFun, buf, addrMaker)
switch labelToSend{
	
	case "isGood":
		return

			
	case "isBad":
		continue T

			
default:
	panic("Invalid label sent at selection choice")
}
		
	
}
		
}
			
	